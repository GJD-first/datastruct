# 相交链表

## 题目叙述

已知两个链表的头节点分别为**listA**和**listB**，判断两个链表是否相交

## 数据结构

```c++
class LinkList{
public:
	int val;
	LinkList* next;
	LinkList(int x) : val(x), next(NULL){};
};
```

## 题目分析



## 题解

### 解法1

```c++
bool check(LinkList *list1, LinkList *list2)
{
    if (list1 == NULL || list2 == NULL)
		return false;
	while (list1 != NULL)
	{
		LinkList *p = list2;
		while (p != NULL && p != list1)
		{
			p = p->next;
		}
		if (p == list1)
			return true;
		list1 = list1->next;
	}
	return false;
}
```

时间复杂度$O(n1*n2)$，空间复杂度$O(1)$

### 解法2

```c++
bool check(LinkList *list1, LinkList *list2)
{
    if (list1 == NULL || list2 == NULL)
		return false;
	set<LinkList *> s;
	while (list1 != NULL)
	{
		s.insert(list1);
		list1 = list1->next;
	}
	while (list2 != NULL)
	{
		if(s.find(list2)!=s.end())
			return true;
		list2 = list2->next;
	}
	
	return false;
}
```

时间复杂度$O(n1+n2)$，空间复杂度$O(n)$

### 解法3

我们把第一个链表的最后一个节点接在第二条链表的头节点之前

- 若两条链表不相交，那么连接之后会得到一个以**list1**为头节点的新链表，以**list2**的尾节点结束
- 若两节点相交，那么最后一个节点既是第一个链表的尾节点，也是第二个链表的尾节点，那么**list2**链表便会形成一个环

> 通过遍历新的链表中的**list2**是否在环中，判断原来的两个链表是否相交

```c++
bool check(LinkList *list1, LinkList *list2)
{
	if (list1 == NULL || list2 == NULL)
		return false;
	while (list1->next != NULL)
	{
		list1 = list1->next;
	}
	list1->next = list2;
	LinkList *p = list2->next;
	while (p != NULL)
	{
		if (p == list2)
			return true;
		p = p->next;
	}
	return false;
}
```

时间复杂度$O(n1+n2)$，空间复杂度$O(1)$